use std::{ffi::OsStr, path::Path};

use anyhow::{bail, Context, Result};
use ini::Ini;
use std::io::Write;
use tantivy::{
    collector::TopDocs,
    doc,
    query::QueryParser,
    schema::{Schema, INDEXED, STORED, TEXT},
    Index, Score,
};
use tracing::{trace, warn};

use crate::{
    models::config::{
        ConfigEntries, ConfigEntry, ConfigLocation, ConfigMetadata, ConfigValueType, ConfigVariant,
        IniSection, MetadataEntry,
    },
    settings_utils::get_default_global_settings_path,
};

pub fn load_config_metadata() -> Result<ConfigMetadata> {
    let mut metadata_path = get_default_global_settings_path();
    metadata_path.set_file_name("config_metadata.json");

    trace!("Trying to config metadata from {}", metadata_path.display());

    let metadata_json = std::fs::File::open(&metadata_path)
        .with_context(|| format!("Failed to read metadata file {:?}", metadata_path))?;

    serde_json::from_reader(metadata_json)
        .with_context(|| format!("Failed to parse metadata file {:?}", metadata_path))
}

pub fn save_config_metadata(metadata: &ConfigMetadata) -> Result<()> {
    let mut metadata_path = get_default_global_settings_path();
    metadata_path.set_file_name("config_metadata.json");

    let metadata_json = serde_json::to_string_pretty(metadata)
        .with_context(|| "Failed to convert ConfigMetadata to JSON")?;

    std::fs::File::create(&metadata_path)
        .and_then(|mut f| f.write_all(metadata_json.as_bytes()))
        .with_context(|| format!("Failed to create metadata file {}", metadata_path.display()))
}

pub(crate) fn import_config_file(file: impl AsRef<str>) -> Result<(ConfigMetadata, ConfigEntries)> {
    let file = file.as_ref();
    let ini = Ini::load_from_file(file)?;
    let file_name = if let Some(Some(file_name)) = Path::new(file).file_name().map(OsStr::to_str) {
        file_name
    } else {
        bail!("Failed to get file name from {}", file);
    };

    let mut config_metadata = ConfigMetadata::default();
    let mut config_entries = ConfigEntries::default();

    for (section, properties) in ini.iter() {
        let section = section
            .map(IniSection::from)
            .unwrap_or(IniSection::Custom(String::new()));

        let location = ConfigLocation::IniOption(file_name.into(), section);
        for (key, value) in properties.iter() {
            let value_type = ConfigValueType::infer_from(value);
            let default_value = match ConfigVariant::from_type_and_value(&value_type, value) {
                Ok(v) => v,
                Err(e) => {
                    warn!(
                        "Failed to parse value [{}] as {}: {}",
                        value,
                        value_type,
                        e.to_string()
                    );
                    continue;
                }
            };
            let metadata_entry = MetadataEntry {
                name: key.into(),
                location: location.clone(),
                is_autogenerated: true,
                description: format!(
                    "Auto imported - validate the configuration for this before using it"
                ),
                value_type: value_type.clone(),
                default_value: Some(default_value.clone()),
            };
            config_metadata.entries.push(metadata_entry);

            let config_entry = ConfigEntry {
                meta_name: key.to_owned(),
                value: default_value.clone(),
            };
            config_entries.entries.push(config_entry);

            trace!(
                "Location: {} Key: {} Type: {} Value: {}",
                location,
                key,
                value_type,
                default_value
            );
        }
    }

    Ok((config_metadata, config_entries))
}

// TODO: If we merge the metadata and a type is changed, we will probably want some way to notify or reconcile those changes
pub fn merge_metadata(original: &mut ConfigMetadata, mut new: ConfigMetadata) {
    for new_entry in new.entries.drain(..) {
        if let Some((index, original_entry)) = original
            .entries
            .iter()
            .enumerate()
            .find(|(_, v)| v.name == new_entry.name && v.location == new_entry.location)
        {
            if original_entry.is_autogenerated {
                trace!(
                    "Replacing [{}] {}",
                    original_entry.location,
                    original_entry.name
                );
                original.entries[index] = new_entry
            }
        } else {
            trace!("Adding [{}] {}", new_entry.location, new_entry.name);
            original.entries.push(new_entry);
        }
    }
}

pub fn create_metadata_index() -> Index {
    let mut schema_builder = Schema::builder();
    schema_builder.add_text_field("name", TEXT | STORED);
    schema_builder.add_text_field("description", TEXT);
    schema_builder.add_json_field("location", TEXT | STORED);
    schema_builder.add_text_field("ini_file", TEXT);
    schema_builder.add_text_field("ini_section", TEXT);
    schema_builder.add_bool_field("is_autogenerated", INDEXED);
    let schema = schema_builder.build();

    Index::create_in_ram(schema)
}

pub fn rebuild_index_with_metadata<'a>(
    index: &'a mut Index,
    entries: impl IntoIterator<Item = &'a MetadataEntry>,
) -> Result<()> {
    clear_metadata_index(index)
        .and_then(|_| add_metadata_entries_to_index(index, entries.into_iter()))
}

fn clear_metadata_index(index: &mut Index) -> Result<()> {
    trace!("Clearing metadata index");
    let mut index_writer = index.writer(15_000_000)?;

    index_writer
        .delete_all_documents()
        .with_context(|| "Failed to delete documents")?;
    index_writer
        .commit()
        .map(|_| ())
        .with_context(|| "Failed to commit document delete")
}

fn add_metadata_entries_to_index<'a>(
    index: &'a mut Index,
    entries: impl Iterator<Item = &'a MetadataEntry>,
) -> Result<()> {
    let schema = index.schema();
    let name = schema.get_field("name")?;
    let description = schema.get_field("description")?;
    let location = schema.get_field("location")?;
    let is_autogenerated = schema.get_field("is_autogenerated")?;
    let ini_file = schema.get_field("ini_file")?;
    let ini_section = schema.get_field("ini_section")?;

    let mut index_writer = index.writer(15_000_000)?;

    // TODO: Might need to find a way to use https://docs.rs/tantivy/latest/tantivy/tokenizer/struct.NgramTokenizer.html to perform
    // substring searches
    let mut index_count = 0;
    for metadata in entries {
        let location_json = serde_json::to_value(&metadata.location)?;
        let location_map = location_json
            .as_object()
            .expect("Failed to convert location to JSON object")
            .to_owned();
        let mut document = doc!(
            name => metadata.name.to_owned(),
            description => metadata.description.to_owned(),
            location => location_map,
            is_autogenerated => metadata.is_autogenerated
        );

        if let ConfigLocation::IniOption(file, section) = &metadata.location {
            document.add_text(ini_file, file.to_string());
            document.add_text(ini_section, section.to_string());
        }

        index_writer.add_document(document)?;
        index_count += 1;
    }
    index_writer
        .commit()
        .with_context(|| "Failed to commit index update")?;
    trace!("Indexed {} metadata entries", index_count);
    Ok(())
}

pub struct QueryResult {
    pub score: Score,
    pub name: String,
    pub location: ConfigLocation,
}

pub fn query_metadata_index(index: &Index, query: &str) -> Result<Vec<QueryResult>> {
    if query.len() < 3 {
        return Ok(Vec::new());
    }

    let schema = index.schema();
    let name = schema.get_field("name")?;
    let description = schema.get_field("description")?;
    let location = schema.get_field("location")?;
    // let is_autogenerated = schema.get_field("is_autogenerated")?;
    // let ini_file = schema.get_field("ini_file")?;
    // let ini_section = schema.get_field("ini_section")?;

    let reader = index.reader()?;
    let searcher = reader.searcher();
    let mut query_parser = QueryParser::for_index(&index, vec![name, description, location]);
    query_parser.set_field_fuzzy(name, true, 0, false);
    let query = query_parser.parse_query(query)?;

    let result = searcher
        .search(&query, &TopDocs::with_limit(50))?
        .drain(..)
        .map(|(score, address)| searcher.doc(address).map(|d| (score, d)))
        .collect::<Result<Vec<(_, _)>, _>>()?
        .drain(..)
        .map(|(s, d)| QueryResult {
            score: s,
            name: d
                .get_first(name)
                .expect("Failed to extract name field")
                .as_text()
                .expect("Failed to extract text from name value")
                .to_owned(),
            location: serde_json::from_value(serde_json::Value::Object(
                d.get_first(location)
                    .expect("Failed to extract location field")
                    .as_json()
                    .expect("Failed to extract json from location value")
                    .to_owned(),
            ))
            .expect("Failed to convert location into ConfigLocation"),
        })
        .collect::<Vec<QueryResult>>();

    trace!("{} results", result.len());
    Ok(result)
}
