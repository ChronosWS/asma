use std::{ffi::OsStr, path::Path};

use anyhow::{bail, Context, Result};
use ini::Ini;
use tracing::{trace, warn};

use crate::{
    models::config::{
        ConfigEntries, ConfigEntry, ConfigLocation, ConfigMetadata, ConfigValueType, ConfigVariant,
        IniSection, MetadataEntry,
    },
    settings_utils::get_default_global_settings_path,
};

pub fn load_config_metadata() -> Result<ConfigMetadata> {
    let mut metadata_path = get_default_global_settings_path();
    metadata_path.set_file_name("config_metadata.json");

    let metadata_json = std::fs::File::open(&metadata_path)
        .with_context(|| format!("Failed to read metadata file {:?}", metadata_path))?;

    serde_json::from_reader(metadata_json)
        .with_context(|| format!("Failed to parse metadata file {:?}", metadata_path))
}

pub(crate) fn import_config_file(file: impl AsRef<str>) -> Result<(ConfigMetadata, ConfigEntries)> {
    let file = file.as_ref();
    let ini = Ini::load_from_file(file)?;
    let file_name = if let Some(Some(file_name)) = Path::new(file).file_name().map(OsStr::to_str) {
        file_name
    } else {
        bail!("Failed to get file name from {}", file);
    };

    let mut config_metadata = ConfigMetadata::default();
    let mut config_entries = ConfigEntries::default();

    for (section, properties) in ini.iter() {
        let section = section
            .map(IniSection::from)
            .unwrap_or(IniSection::Custom(String::new()));

        let location = ConfigLocation::IniOption(file_name.into(), section);
        for (key, value) in properties.iter() {
            let value_type = ConfigValueType::infer_from(value);
            let default_value = match ConfigVariant::from_type_and_value(&value_type, value) {
                Ok(v) => v,
                Err(e) => {
                    warn!(
                        "Failed to parse value [{}] as {}: {}",
                        value,
                        value_type,
                        e.to_string()
                    );
                    continue;
                }
            };
            let metadata_entry = MetadataEntry {
                name: key.into(),
                location: location.clone(),
                is_autogenerated: true,
                description: format!(
                    "Auto imported - validate the configuration for this before using it"
                ),
                value_type: value_type.clone(),
                default_value: Some(default_value.clone()),
            };
            config_metadata.entries.push(metadata_entry);

            let config_entry = ConfigEntry {
                meta_name: key.to_owned(),
                value: default_value.clone(),
            };
            config_entries.entries.push(config_entry);

            trace!(
                "Location: {} Key: {} Type: {} Value: {}",
                location,
                key,
                value_type,
                default_value
            );
        }
    }

    Ok((config_metadata, config_entries))
}

// TODO: If we merge the metadata and a type is changed, we will probably want some way to notify or reconcile those changes
pub fn merge_metadata(original: &mut ConfigMetadata, mut new: ConfigMetadata) {
    for new_entry in new.entries.drain(..) {
        if let Some((index, original_entry)) = original
            .entries
            .iter()
            .enumerate()
            .find(|(_, v)| v.name == new_entry.name && v.location == new_entry.location)
        {
            if original_entry.is_autogenerated {
                trace!("Replacing [{}] {}", original_entry.location, original_entry.name);
                original.entries[index] = new_entry
            }
        } else {
            trace!("Adding [{}] {}", new_entry.location, new_entry.name);
            original.entries.push(new_entry);
        }
    }
}
